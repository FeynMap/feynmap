# Варианты раскладки дерева, которые не сработали

Документ фиксирует подходы к позиционированию дерева (Top-to-Bottom, горизонтальные ряды, центрирование родителя над детьми, коллизии), которые в итоге не дали требуемого результата в браузере.

---

## 1. Изначальная раскладка (первая версия)

**Идея:** Дерево сверху вниз, дети в ряд. Ширина поддерева = сумма ширин детей + зазоры или `nodeWidth` для листа. Начальное размещение: дети центрируются под родителем, затем разрешение коллизий по уровням.

**Что делали:**
- `buildLayoutTree`: снизу вверх считали `subtreeWidth`.
- `assignInitialX`: родитель в центре строки детей, слот каждого ребёнка = `child.width`.
- `updateExtents`, `resolveCollisionsAtLevel`: по уровням сдвигали перекрывающиеся поддеревья.
- `centerRoot`: сдвиг всего дерева так, чтобы корень был в x=0.

**Почему не подошло:** В браузере расположение элементов не соответствовало требованиям (родитель не по центру над детьми, уровни/ряды выглядели неверно).

---

## 2. Передача позиции как top-left в React Flow

**Идея:** В React Flow по умолчанию `position` — верхний левый угол узла. Передавали координаты угла: `position: { x: n.x - boxSize.width/2, y: n.y - boxSize.height/2 }`, считая `n.x, n.y` центром узла.

**Проблема:** Фактическая ширина узла задаётся CSS (`min-w-[120px]`) и может отличаться от `boxSize.width` (140). Центр узла на экране не совпадал с расчётным центром раскладки.

---

## 3. Центр узла + nodeOrigin [0.5, 0.5]

**Идея:** Убрать зависимость от размера карточки: передавать в React Flow центр узла `position: { x: n.x, y: n.y }` и задать `nodeOrigin={[0.5, 0.5]}`.

**Результат:** Пользователь сообщил, что это «не решение» и нужен кардинально другой подход. То есть визуальный результат по-прежнему не соответствовал требованиям (горизонтально-разветвлённое дерево, родитель строго по центру над детьми, ряды по уровням, ветки не перекрываются).

---

## 4. Перецентровка родителей после коллизий (recenterParentsOverChildren)

**Идея:** После сдвига узлов при коллизиях родители перестают быть над центром детей. Добавлен проход post-order: для каждого родителя `node.x = (leftMost + rightMost) / 2` по экстентам прямых детей.

**Результат:** Логика центрирования улучшена в коде, но в совокупности с остальными подходами итог в браузере всё равно не устроил пользователя — потребовалось «глубокое научное исследование» и другой метод позиционирования.

---

## 5. Блокировка перетаскивания узлов

**Идея:** Сохранить расчётную раскладку: `nodesDraggable={false}`, `nodesConnectable={false}`.

**Замечание:** Это не алгоритм позиционирования, а защита от случайного сдвига. Само по себе не решает проблему неверного расположения.

---

## Итог

Перечисленные варианты не привели к удовлетворяющему результату. Требуется принципиально иной подход к алгоритму раскладки (например, на основе Reingold–Tilford, Buchheim и др. или готовых библиотек/документации по tree layout) и, при необходимости, уточнение требований к визуалу и поведению в браузере.

---

## 6. Исправления по промпту (Buchheim + выравнивание размеров)

**Учтённые ошибки из пунктов 1–4:**

1. **Алгоритм:** Вместо кастомной раскладки с коллизиями по уровням реализован алгоритм **Buchheim et al.** (Reingold–Tilford), как в D3: firstWalk/secondWalk, prelim/mod/shift, обход контуров (nextLeft/nextRight), moveSubtree. Родитель строго по центру над полной шириной группы детей; уровни — горизонтальные ряды; ветки не перекрываются за счёт контурного раздвигания.

2. **Размер узла и центр (п. 2–3):** В раскладке используется **тот же размер узла, что и в отрисовке**. `LayoutConfig.nodeWidth = 120` и дерево-узлы в TreeCanvas имеют фиксированный размер **120×44 px** (`w-[120px] h-[44px]`). Тогда расчётный центр раскладки совпадает с визуальным центром узла при `position: { x: n.x, y: n.y }` и `nodeOrigin={[0.5, 0.5]}`.

3. **Фиксированный размер узла:** У дерева-узла убран `min-w-[120px]` и заданы явные `w-[120px] h-[44px]`, чтобы центр узла всегда был в одном и том же месте относительно блока и совпадал с координатами из layout.

**Итог:** Алгоритм раскладки соответствует промпту (рекурсивная структура, горизонтальные уровни, динамическое пространство, центрирование родителя над группой детей); размеры layout и отрисовки согласованы, чтобы центры совпадали в браузере.
